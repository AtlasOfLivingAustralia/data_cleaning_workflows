---
title: "caab"
author: "Fonti Kar"
date: "2022-10-17"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

pacman::p_load(here, tidyverse, janitor, skimr, stringr, jsonlite, httr, job)

source("scripts/remove_improper_names_v2.R") # Version Fonti created
```

## CAAB List

CAAB stands for the Codes for Australian Aquatic Biota. The original version can be found [here](http://www.cmar.csiro.au/oldcaab/). The interface has since been updated and accessed through via[https://www.cmar.csiro.au/data/caab/](https://www.cmar.csiro.au/data/caab/).

CAAB offers a bulk ['dump' download](http://www.marine.csiro.au/datacentre/caab/caab_dump_latest.xlsx) which may be useful for excluding marine species from the Australian Faunal Directory for IA. I've converted the excel file into a .csv.

I believe NESP was able to be called via `ALA4R` in the past using code developed by Matilda. So IA is interested to know if CAAB is still a viable solution to the marine exclusion problem. 

One benefit of the CAAB is that it is limited to Australian species so the download is smaller and 

### Read in CAAB list and AFD list

```{r}
caab_dump <- read_csv(here("ignore", "data", "caab_dump_latest.csv"))
skim(caab_dump)

afd_species <- read_csv(here("output", "afd_splist_full.csv"))

skim(afd_species)
```

### Common columns between CAAB and AFD

IA uses `VALID_NAME` for excluding GRIIS species and marine species with WoRMS

```{r}
names(afd_species)
names(caab_dump)

# Looks a little messy, looks of spp.  and odd formatting
caab_dump$SCIENTIFIC_NAME 

# Can probably concatenate these together and exclude NAs
caab_dump %>% select(GENUS, SPECIES) 
caab_dump %>% mutate(scientificName = ifelse(is.na(GENUS) | is.na(SPECIES),
                                            NA, 
                                            paste(GENUS, SPECIES))
                     ) -> caab_dump

#  How many NA? 
is.na(caab_dump$scientificName) %>% table() #21K Not ideal! 
```

### Are there any improper names?

Number of retained is about the same! Will stick with the original SCIENTIFIC_NAME for rest of workflow

```{r}
x <- remove_improper_names_v2(caab_dump$scientificName) 
# Cleaning checklist for improper species names...
# # Improper names (indicated by NAs) in updated species list: 1276
# Original number of species: 65770
# Number of species removed: 1276
# Number of species retained: 43243
# Proprotion of species removed: 0.019400942679033
# Is #species retained = #species in raw list - #species removed? : FALSE

y <- remove_improper_names_v2(caab_dump$SCIENTIFIC_NAME) 
# Cleaning checklist for improper species names...
# # Improper names (indicated by NAs) in updated species list: 22558
# Original number of species: 65770
# Number of species removed: 22569
# Number of species retained: 43206
# Proprotion of species removed: 0.343150372510263
# Is #species retained = #species in raw list - #species removed? : FALSE
```

### Looking at cleaned CAAB names

I see some `var.`. will exclude these for now

```{r}
# Subspecies
str_subset(y$updated_list, pattern = "var. ") 
str_subset(y$updated_list, pattern = "var. ") %>% length()

 # Exclude these subspecies
cleaned_caab <- str_remove(y$updated_list, pattern = "var. ")
```

### Cross matching with AFD using updated list

```{r}
message(which(afd_species$VALID_NAME %in% cleaned_caab) %>% length(), " AFD species matched with CAAB database")
message("Excluding AFD species found in CAAB database:")
afd_species %>% filter(! VALID_NAME %in% cleaned_caab) -> afd_species_cleaned 
message(cat("Proportion of AFD species excluded:", afd_species %>% filter(VALID_NAME %in% cleaned_caab) %>% nrow() / afd_species %>% nrow() ))
```

## CAAB API

I spoke to Dave Watts at NCMI Hobart who manages the CAAB list. He was very helpful and said that the bulk download isn't regularly updated so its best to query the API he built to access CAAB data. 

He flagged that the Inverts data is currently not actively managed as the previous curator has moved on from the role. 

Importantly, the habitat flags in CAAB data is obtained from WoRMS and there is an ongoing relationship between the two data sources.

Watts also noted that CAAB is likely to capture Australian species that is not yet on WoRMS.

The API is found here: https://www.marine.csiro.au/data/services/caab/

Below I have developed a workflow to query the API and collate the neccesarry data for exclude marine species from the AFD

### A first example

A handy tutorial if you have never worked with APIs in R before: https://www.dataquest.io/blog/r-api-tutorial/

```{r}
# A definite marine species
test_species <- c("Hydroides dirampha")

# Replace space with + as that is how API interprets spaces
species_query <- stringr::str_replace(test_species, " ", "+")

# Set up the API query
API_address <- c("https://www.marine.csiro.au/data/services/caab/")
query <-c("?q=")

# Query the API
res <- GET(glue::glue(API_address,query,species_query))
```

#### Check out results
```{r}
# Look at the results, this is the same if we pasted the query directly in the URL of a browswer
res$content %>% rawToChar() 

# Convert
rawToChar(res$content) %>% fromJSON() -> res_formatted

# Check if marine or not  
res_formatted$habitat

# This might be a nicer output
res_formatted %>% tibble()
```

### A function to query CAAB API

```{r}
query_CAAB <- function(taxon_name){
# Replace space with + as that is how API interprets spaces
species_query <- stringr::str_replace_all(taxon_name, " ", "+")

# Set up the API query
API_address <- c("https://www.marine.csiro.au/data/services/caab/")
query <-c("?q=")

# Query the API
res <- httr::GET(glue::glue(API_address,query,species_query))

# Convert
rawToChar(res$content) %>% fromJSON() -> res_formatted

# This might be a nicer output
res_formatted <- res_formatted %>% dplyr::tibble() 

# Handle diff classes types
if(nrow(res_formatted) > 0){
  res_formatted %>% mutate(search_term = taxon_name,
                          CAAB_code = as.character(CAAB_code),
                           Parent_Id = as.character(Parent_Id))
  }
}

query_CAAB("Hydroides dirampha") # Works :)=
```

#### Trying to loop through a short species list

```{r}
set.seed(10)

sp_list <- sample(afd_species$VALID_NAME, 100)

res_ls <- purrr::map_df(.x = sp_list, 
                        .f = ~query_CAAB(.x))

# Looking at output
res_ls %>% filter(habitat == "") %>% View() # These look like Marine species but no habitat info
```

### RStudio background job

Nope too many issues with the AFD

```{r}
cleaned_names <- remove_improper_names_v2(afd_species$VALID_NAME)
cleaned_names$updated_list

ls <- split(cleaned_names$updated_list, ceiling(seq_along(cleaned_names$updated_list)/1000))

res_ls <- purrr::map_df(.x = ls[[1]], 
                        .f = ~query_CAAB(.x))

res_ls_2 <- purrr::map_df(.x = ls[[2]], 
                        .f = ~query_CAAB(.x))

res_ls <- purrr::map_df(.x = cleaned_names$updated_list, 
                        .f = ~query_CAAB(.x))

# Bad name  "Lamispina\001 horstii" I think this is a unicode
# "Brancuporus\022 pennifoldae"

job({
  res_ls <- purrr::map_df(.x = cleaned_names$updated_list, 
                          .f = ~query_CAAB(.x))
  saveRDS(res_ls, "output/CAAB_api_output.rds")
  })
```

#### Test for loop

```{r}
# AFD taxa as list 
cleaned_names <- remove_improper_names_v2(afd_species$VALID_NAME)
cleaned_afd_taxon_names <- cleaned_names$updated_list

afd_taxon_nm_ls <- as.list(cleaned_afd_taxon_names)

# Index vector to track progress
loop_index_1 <- 0  

# Test seems to work well! 
test <- afd_taxon_nm_ls[1:100]

res_ls <- list()

for (i in 1:length(test)) {
  # Print progress
  loop_index_1 <- loop_index_1 + 1
  print(paste0(test[[i]], ":", loop_index_1,"/", length(test)))

  try(res_ls[[i]] <- 
        query_CAAB(test[[i]])
      ) 
}


# Test RStudio job
job({
  
  # Index vector to track progress
  loop_index_1 <- 0  
  
  # Test seems to work well! 
  test <- afd_taxon_nm_ls[1:100]
  
  # Empty result list
  res_ls <- list()
  
  for (i in 1:length(test)) {
    # Print progress
    loop_index_1 <- loop_index_1 + 1
    print(paste0(test[[i]], ":", loop_index_1,"/", length(test)))
    
    try(res_ls[[i]] <- 
          query_CAAB(test[[i]])
    ) 
  }
  
  CAAB_result <- bind_rows(res_ls)
  
  write.csv(CAAB_result, "output/CAAB_AFD_result_test.csv", row.names = FALSE)
  
})
```

### Full loop

```{r}
# AFD taxa as list 
cleaned_names <- remove_improper_names_v2(afd_species$VALID_NAME)
cleaned_afd_taxon_names <- cleaned_names$updated_list

afd_taxon_nm_ls <- as.list(cleaned_afd_taxon_names)

# RStudio Job

job({
  
  # Create empty list to populate API result
  res_ls <- list()
  
  # Index vector
  loop_index_1 <- 0  
  
  for (i in 1:length(afd_taxon_nm_ls)) {
    # Print progress
    loop_index_1 <- loop_index_1 + 1
    print(paste0(afd_taxon_nm_ls[[i]], ":", loop_index_1,"/", length(afd_taxon_nm_ls)))
    
    try(res_ls[[i]] <- 
          query_CAAB(afd_taxon_nm_ls[[i]])
    ) 
  }
  
  CAAB_result <- bind_rows(res_ls)
  
  write.csv(CAAB_result, "output/CAAB_AFD_result.csv", row.names = FALSE)
  
})
```





---
title: "Computing alpha hulls"
author: "Fonti Kar"
date: "2022-09-05"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = FALSE,
                      include = FALSE)

pacman::p_load(tidyverse, alphahull, sp, igraph, concaveman, rgdal, sf, dplyr)

# source("./scripts/conr_iucn_eval.R")
# source("./scripts/species_polygons.R")
```

Resources on alpha hulls: 
- https://www.r-bloggers.com/2012/12/flexibly-outlining-a-set-of-points-with-alphahull/
- https://yihui.org/en/2010/04/alphahull-an-r-package-for-alpha-convex-hull/
- https://rpubs.com/geospacedman/alphasimple
- https://github.com/babichmorrowc/hull2spatial
- https://github.com/joelgombin/concaveman
- https://stackoverflow.com/questions/72449104/converting-alpha-hulls-to-spatial-polygon
- https://cran.r-project.org/web/packages/alphahull/alphahull.pdf
- https://rpubs.com/geospacedman/alphasimple

## Investigating data from IA

```{r}
ala_df <- read_csv("./output/data_invertebrates_ALAonly.csv")

str(ala_df)
```

## Testing out example code from ConR package - abort!

```{r, eval = FALSE}
data(dataset.ex)
data(land)
## Not run: 
Results <- IUCN.eval(dataset.ex, country_map=land,
                     alpha = 2,
                     method.range = "alpha.hull",
                     write_file_option = "csv", 
                     export_shp = TRUE, ## to get SpatialPolygonsDataFrame in output
                     write_results = TRUE,
                     write_shp = FALSE, ## to write shapefile files to folder
                     SubPop = FALSE,
                     DrawMap = FALSE,
                     showWarnings = FALSE)

xResults <- IUCN.eval(dataset.ex, 
                     country_map=land, Cell_size_locations=10,
                     Resol_sub_pop = 5, Cell_size_AOO = 4, method_locations="sliding scale")
```

## Testing out code in this blog post

https://babichmorrowc.github.io/post/2019-03-18-alpha-hull/

This convex hull (drawn in magenta) is an example of an α-shape: all convex hulls are α-shapes, but not all α-shapes are convex hulls. An α-shape doesn’t have to be convex – the lines making up the border of the shape can create concave edges relative to the points in the dataset.

```{r}
remotes::install_github("babichmorrowc/hull2spatial")

library(hull2spatial)

data(iris)
iris_sepals <- iris[,1:2]
# remove duplicate datapoints
iris_sepals <- iris_sepals[!duplicated(paste(iris_sepals$Sepal.Length, iris_sepals$Sepal.Width)), ]

alphahull_1 <- ahull(iris_sepals, alpha = 1)
hullpoly_1 <- hull2spatial::ahull2poly(alphahull_1)
plot(hullpoly_1, border = "magenta", add = TRUE)

# Save the polygon as a shapefile
# Code from here: https://gis.stackexchange.com/questions/61633/convert-a-spatial-polygon-object-to-data-frame-using-r
spp <-SpatialPolygonsDataFrame(hullpoly_1,
                               data=as.data.frame(iris_sepals[1,1]))
writeOGR(spp,"output","testShape",driver="ESRI Shapefile") 

# Seems to work with WARNING
# Warning message:
# In writeOGR(spp, "output", "testShape", driver = "ESRI Shapefile") :
#   Field names abbreviated for ESRI Shapefile driver
```

## Testing code from here using 'sf':
https://stackoverflow.com/questions/72449104/converting-alpha-hulls-to-spatial-polygon

```{r}
ala_df |> 
  group_by(spfile) |> 
  summarise(n_obs = length(spfile)) |> 
  arrange(- n_obs) |> 
  print(n = 100)

# ala_df |> 
#   filter(spfile == "diphyoropa_saturni_7493")  -> test_ala

ala_df |> 
  filter(scientificName == "Austroargiolestes calcaris")  -> test_ala

test_ala  

# Deduplication
test_ala |> 
  filter(! duplicated(longitude) | duplicated(latitude))  |> 
  select(latitude, longitude) -> data
```

## Testing hull2spatial to sf 

```{r}
data |> select(longitude, latitude) -> data

ahull(data, alpha = 4) |> plot() 

ahull(data, alpha = 4) -> alphahull_1

hull2spatial::ahull2poly(alphahull_1) -> sp_df

crs_wgs84 <- CRS(SRS_string = "EPSG:4326")
slot(sp_df, "proj4string") <- crs_wgs84

hull2spatial::ahull2poly(alphahull_1) |> 
  st_as_sf() -> omg


omg %>% st_set_crs(st_crs(aus)) -> omg

ggplot() + 
  geom_sf(data = omg)
```


## Testing concaveman

https://gis.stackexchange.com/questions/302107/defining-convex-hull-of-clouds-of-points-using-r/302110#302110

```{r}
dat.sf <- st_as_sf(data, coords=c("longitude","latitude"), crs = st_crs(4326))
polygon <- concaveman(dat.sf, concavity = 2.5)

plot(dat.sf, pch=16)
plot(polygon, add=T, col=adjustcolor('red', alpha.f=.3), col.line='red', border=2) 
```

## Try plotting a nice map with polygon on it
### Convert ALA data into sf obj

```{r}
test_ala |> 
  mutate(latitude = as.numeric(latitude),
         longitude = as.numeric(longitude)) |> 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) -> occ_sf


aus <- st_transform(ozmaps::ozmap_country, 4326)

ggplot() + 
  geom_sf(data = aus, colour = "black", fill = "white")  +
  geom_sf(data = occ_sf, colour = "black") + 
  geom_sf(data = polygon, fill = "orange", alpha = 0.5) +
  coord_sf(xlim=c(140, 155),ylim=c(-30,-45)) +
  guides(colour = guide_legend(override.aes = list(alpha=1))) + 
  theme(legend.position = "bottom")

ggplot() + 
  geom_sf(data = aus, colour = "black", fill = "white")  +
  geom_sf(data = occ_sf, colour = "black") + 
  geom_sf(data = omg, fill = "orange", alpha = 0.5) +
  coord_sf(xlim=c(140, 155),ylim=c(-30,-45)) +
  guides(colour = guide_legend(override.aes = list(alpha=1))) + 
  theme(legend.position = "bottom")
```

## Try alphahull the package

```{r}
my.ashape = dat.ashape

hull2poly <- function(my.ashape){
  require(sf)
  if(class(my.ashape) != "ashape") {stop('error, your input must be 
     ashape class')} else
     my.edge<- data.frame(my.ashape$edges)[,c( 'x1', 'y1', 'x2', 'y2')]
     x<- my.edge[,1:2]
     y<- my.edge[,3:4]
     my.edge2<- matrix(t(cbind(x,y)), byrow=T,ncol=2)
     my.edge2<- as.data.frame(my.edge2)
     names(my.edge2)<- c('x','y')
     my.edge2$id <- unlist(lapply((1: (nrow(my.edge2)/2)), 
                                  FUN=function(x){c(rep(x,2))}))

     start.edge<- 1
     new.id<- start.edge
     new.edges<- my.edge2[which(my.edge2$id== start.edge ),]

     while(length(new.id)<= length(unique(my.edge2$id))-1){
           internal.id<- new.id[length(new.id)]
           edge <- my.edge2[which(my.edge2$id== internal.id ),]
           where.to.search <- my.edge2[which(my.edge2$id %in% new.id ==F ),]
  
     index1<- apply(where.to.search[,1:2], 1, function(x){x == edge[1,1:2]})
     index1<- as.numeric(names(which(apply(index1,2, sum)>0)))[1]
     index2<- apply(where.to.search[,1:2], 1, function(x){x == edge[2,1:2]})
     index2<- as.numeric(names(which(apply(index2,2, sum)>0)))[1]
     main.index<- c(index1, index2)
  
     ifelse(all(!is.na(main.index)), 
         # yes
         {flag<- c(T,T)
         main.index<- main.index[2]
         point.coord<- my.edge2[main.index,] 
         segment<- my.edge2[my.edge2$id==my.edge2[main.index,'id'],]
         new.id<- c( new.id, my.edge2[main.index,]$id) },
         
         # no
         ifelse(which(!is.na(main.index))==1, 
                # yes
                {flag<- c(T,F)
                main.index<- main.index[flag]
                point.coord<- my.edge2[main.index,] 
                segment<- 
     my.edge2[my.edge2$id==my.edge2[main.index,'id'],]
                new.id<- c( new.id, my.edge2[main.index,]$id)},
                # no
                {flag<- c(F,T)
                main.index<- main.index[flag]
                point.coord<- my.edge2[main.index,] 
                segment<- my.edge2[my.edge2$id==my.edge2[main.index,'id'],]
                new.id<- c( new.id, my.edge2[main.index,]$id)}  ) )
  
        index3<- t(apply(segment, 1, function(x){x ==point.coord}))
  
        new.edges<- rbind(new.edges, rbind(point.coord, segment[which(apply(index3,1, sum)<3),]))
}
tst <- st_multipoint(as.matrix(new.edges[1:2]), dim = "XYZ") |> st_sfc(crs = 4326)
poly<- tst %>% # 
  st_cast('POLYGON')
return(poly)}
```

```{r}
hull2poly <- function(my.ashape){
  require(sf)
  if(class(my.ashape) != "ashape") {stop('error, your input must be 
     ashape class')} else
     my.edge<- data.frame(my.ashape$edges)[,c( 'x1', 'y1', 'x2', 'y2')]
     x<- my.edge[,1:2]
     y<- my.edge[,3:4]
     my.edge2<- matrix(t(cbind(x,y)), byrow=T,ncol=2)
     my.edge2<- as.data.frame(my.edge2)
     names(my.edge2)<- c('x','y')
     my.edge2$id <- unlist(lapply((1: (nrow(my.edge2)/2)), 
                                  FUN=function(x){c(rep(x,2))}))

     start.edge<- 1
     new.id<- start.edge
     new.edges<- my.edge2[which(my.edge2$id== start.edge ),]

     while(length(new.id)<= length(unique(my.edge2$id))-1){
           internal.id<- new.id[length(new.id)]
           edge <- my.edge2[which(my.edge2$id== internal.id ),]
           where.to.search <- my.edge2[which(my.edge2$id %in% new.id ==F ),]
  
     index1<- apply(where.to.search[,1:2], 1, function(x){x == edge[1,1:2]})
     index1<- as.numeric(names(which(apply(index1,2, sum)>0)))[1]
     index2<- apply(where.to.search[,1:2], 1, function(x){x == edge[2,1:2]})
     index2<- as.numeric(names(which(apply(index2,2, sum)>0)))[1]
     main.index<- c(index1, index2)
  
     ifelse(all(!is.na(main.index)), 
         # yes
         {flag<- c(T,T)
         main.index<- main.index[2]
         point.coord<- my.edge2[main.index,] 
         segment<- my.edge2[my.edge2$id==my.edge2[main.index,'id'],]
         new.id<- c( new.id, my.edge2[main.index,]$id) },
         
         # no
         ifelse(which(!is.na(main.index))==1, 
                # yes
                {flag<- c(T,F)
                main.index<- main.index[flag]
                point.coord<- my.edge2[main.index,] 
                segment<- 
     my.edge2[my.edge2$id==my.edge2[main.index,'id'],]
                new.id<- c( new.id, my.edge2[main.index,]$id)},
                # no
                {flag<- c(F,T)
                main.index<- main.index[flag]
                point.coord<- my.edge2[main.index,] 
                segment<- my.edge2[my.edge2$id==my.edge2[main.index,'id'],]
                new.id<- c( new.id, my.edge2[main.index,]$id)}  ) )
  
        index3<- t(apply(segment, 1, function(x){x ==point.coord}))
  
        new.edges<- rbind(new.edges, rbind(point.coord, segment[which(apply(index3,1, sum)<3),]))
}
tst <- st_multipoint(as.matrix(new.edges), dim = "XYZ")
poly<- tst %>% # 
  st_cast('POLYGON')
return(poly)}
```

```{r}
dat.ashape<- ashape(data, alpha= 2) 

plot(data)
plot(dat.ashape)

c <- hull2poly(dat.ashape)




ggplot() + 
  geom_sf(data = aus, colour = "black", fill = "white")  +
  geom_sf(data = occ_sf, colour = "black") + 
  geom_sf(data = polygon, fill = "orange", alpha = 0.5) +
  coord_sf(xlim=c(140, 155),ylim=c(-30,-45)) +
  guides(colour = guide_legend(override.aes = list(alpha=1))) + 
  theme(legend.position = "bottom")


ggplot() + 
  geom_sf(data = aus, colour = "black", fill = "white")  +
  geom_sf(data = occ_sf, colour = "black") + 
  geom_sf(data = polygon, fill = "orange", alpha = 0.5) +
  coord_sf(xlim=c(140, 155),ylim=c(-30,-45)) +
  guides(colour = guide_legend(override.aes = list(alpha=1))) + 
  theme(legend.position = "bottom")



g = st_sfc(st_point(1:2))
st_sf(a=3,g)
```

```{r}
st_multipoint(as.matrix(new.edges), dim = "XYZ") |> st_cast("POLYGON") -> x
x |> st_sf(crs = 4326) -> x

xys = st_as_sf(xy, coords=c("x","y"))


rownames(new.edges) <- colnames(new.edges)  <- NULL
as.matrix(new.edges)
  

st_multipoint(as.matrix(new.edges), dim = "XYM") |> st_cast("POLYGON")


library(alphahull)
set.seed(1)
dat <- matrix(stats::rnorm(1000), ncol = 2)
dat <- as.data.frame(dat)
dat.ashape<- ashape(dat, alpha= 2) 

tmp<- hull2poly(dat.ashape)

plot(tmp)
```

